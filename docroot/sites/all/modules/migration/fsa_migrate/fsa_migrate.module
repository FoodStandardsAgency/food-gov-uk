<?php

/**
 * @file
 * This file contains the specific hooks used for the migration of FSA.
 */

/**
 * When nodes are programmatically updated, we seem to loose pathauto settings.
 * To prevent field collections from updating node aliases for general pages,
 * we disable pathauto for general document pages during the main migration.
 * @param $node
 *
 *
 */
function fsa_migrate_node_update($node) {
  $pathauto_restrict = variable_get('fsa_migrate_pathauto_restrict', FALSE);
  if (in_array($node->type, array('document_page', 'faq'))) {
    $conditions = array('source' => 'node/' . $node->nid, 'language' => LANGUAGE_NONE);
    $path = path_load($conditions);
    if ($path) {
      $node->path['alias'] = $path['alias'];
      //module_load_include('inc', 'pathauto');
      //$uri = entity_uri('node', $node);
      //$pathauto_alias = pathauto_create_alias('node', 'return', $path, array('node' => $node), 'document_page', LANGUAGE_NONE);
      //$node->path['pathauto'] = ($path != $uri['path'] && $path == $pathauto_alias);

      if ($pathauto_restrict) {
        $node->path['pathauto']=false;
      }
    }
  }
}

/**
 * Get hold of the Node id for an alterian id
 * @param $action
 * @param null $value
 * @return null
 */
function fsa_migrate_global_id_map($action, $value = null){
  $map = &drupal_static(__FUNCTION__);
  $result = null;
  if ($action == 'reset') {
    $map = null;
  }
  if (!$map) {
    // initialise the map
    $map = array();
    $tables = array(
      'migrate_map_fsaalertdocument',
      'migrate_map_fsaauditreport',
      'migrate_map_fsaconsultationpage',
      'migrate_map_fsadocumentpage',
      'migrate_map_fsafaqpage',
      'migrate_map_fsamultibranchdocument',
      'migrate_map_fsanewsdocument',
      'migrate_map_fsatreebranchdocument',
    );
    // loop through all our map tables and create one array
    foreach ($tables as $table) {
      $map_section = db_select($table,'m')->fields('m', array('sourceid1','destid1'))->execute()->fetchAllAssoc('sourceid1');
      $map = array_merge($map, $map_section);
    }
  }
  switch($action) {
    case 'dest':
      if (array_key_exists($value,$map)) {
        $result = $map[$value];
      }
    break;
  }
  return $result;
}

