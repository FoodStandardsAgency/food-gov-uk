<?php
/**
 * @file
 * Module file for the FSA enhanced cache clearing module. This is used to clear
 * additional domains from Varnish and to clear URLs from the CloudFlare cache.
 *
 * This module draws heavily on existing functionality provided by the Varnish
 * and Expire modules, without which it will not work.
 */

/**
 * Default value for whether to queue CloudFlare cache purges
 * This can be overridden via the admin user interface.
 */
define('FSA_CACHE_CLEAR_QUEUE_CLOUDFLARE', TRUE);

/**
 * Sets the name of the cloudflare cache queue
 */
define('FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME', 'fsa_cache_clear_cloudflare_urls');

/**
 * Sets the name of the Varnish cache queue
 */
define('FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME', 'fsa_cache_clear_varnish_urls');


/**
 * Determines how much time is available for cache clearing at cron runs.
 */
define('FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME', 180);

/**
 * Implementation of hook_menu().
 */
function fsa_cache_clear_menu() {

  // Configuration interface.
  $items['admin/config/development/fsa-cache-clear'] = array(
    'title' => 'FSA cache clearing',
    'description' => 'Settings for clearing Varnish and CloudFlare caches.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fsa_cache_clear_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'fsa_cache_clear.admin.inc',
  );

  // Settings - default tab
  $items['admin/config/development/fsa-cache-clear/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configuration settings for the cache clearing module',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Purge URLs from the cache(s)
  $items['admin/config/development/fsa-cache-clear/purge'] = array(
    'title' => t('Purge URLs'),
    'description' => t('Purge a URL from the Varnish and/or CloudFlare caches'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fsa_cache_clear_purge_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'fsa_cache_clear.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // View queued items to be purged from CloudFlare
  $items['admin/config/development/fsa-cache-clear/cloudflare-queue'] = array(
    'title' => 'View CloudFlare queue',
    'description' => 'View the list of URLs to be cleared from the CloudFlare cache on cron',
    'page callback' => '_fsa_cache_clear_view_cloudflare_queue',
    'access arguments' => array('administer site configuration'),
    'file' => 'fsa_cache_clear.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}


/*
 * Implements hook_expire_cache().
 *
 * This hook is provided by the Expire module, and will be run according to the
 * configuration settings for that module as specified here:
 * admin/config/system/expire
 *
 */
function fsa_cache_clear_expire_cache($urls, $wildcards, $object_type, $object) {

  // Clear the Varnish cache for any additional domains.
  _fsa_cache_clear_varnish_purge($urls);

  // Clear the CloudFlare cache if activated. This is determined via the
  // configuration UI using a checkbox.
  if (_fsa_cache_clear_settings('clear_cloudflare')) {
    _fsa_cache_clear_cloudflare_purge($urls, $object_type);
  }

}

/**
 * Purge the Varnish cache for the given paths.
 *
 * This is essentially just a wrapper for the varnish_purge() function. The
 * main purpose is to clear paths for any additional domains specified via this
 * module's configuration interface.
 *
 * @param array $paths
 *   An array of paths to be purged from Varnish.
 *
 * @see varnish_purge()
 * @see varnish_expire_cache()
 */
function _fsa_cache_clear_varnish_purge($paths) {

  // This function requires the varnish_purge() function, so if we don't have
  // it, exit now.
  if (!function_exists('varnish_purge')) {
    return;
  }

  // We need $paths to be an array. If it's not, make it one now.
  if (!is_array($paths)) {
    $paths = array($paths);
  }

  // Get the base_path.
  $base = base_path();

  // Get the domains to clear from the settings.
  $domains = _fsa_cache_clear_settings('varnish_domains');

  // Check that we have some domains and that $domains is an array.
  if (empty($domains) || !is_array($domains)) {
    return;
  }

  // Get the $host that the Varnish module already defines. There's no need to
  // clear the cache for that domain a second time.
  $host = function_exists('_varnish_get_host') ? _varnish_get_host() : '';
  // Remove $host from the array of domains - if present.
  //$domains = array_diff($domains, array(trim($host)));

  // Make sure we still have some domains. If not, return now.
  if (empty($domains)) {
    return;
  }

  // For each additional domain, clear the relevant paths from Varnish.
  // @see varnish_expire_cache()
  // We use a wildcard to handle cases such as derived image files where a
  // query string may be present.
  $varnish_wildcard = "(\\\?itok=.*)?$";
  foreach ($domains as $host) {
    $purge = implode($varnish_wildcard . '|^' . $base, $paths);
    $purge = '^'. $base . $purge . $varnish_wildcard;
    varnish_purge($host, $purge);
    _fsa_cache_clear_log_message('varnish_purge', 'Successfully purged @purge for host @host from the Varnish cache.', array('@purge' => $purge, '@host' => $host));
  }
}


/**
 * Clear the CloudFlare cache for the given URLs.
 */
function _fsa_cache_clear_cloudflare_purge($paths = array(), $object_type = NULL) {

  // Get an array of the types of objects for which we want to clear the
  // CloudFlare cache.
  $object_types = array_filter(_fsa_cache_clear_settings('cloudflare_object_types'));

  // If we don't have a path specified, or we don't have an object type, or
  // the object type is not one that we want to clear the CloudFlare cache for,
  // then exit now.
  if (empty($paths) || empty($object_type) || !in_array($object_type, $object_types)) {
    return;
  }

  // Get the limit for the number of items to clear from the CloudFlare cache
  // per page update/deletion.
  $limit = _fsa_cache_clear_settings('cloudflare_max_items');
  // Assume a default limit of 10 items.
  $limit = !empty($limit) ? $limit : 10;
  $counter = 1;

  // An array of path patterns to substitute
  $substitute_patterns = array(
    "/^the-website-of-the-food-standards-agency$/" => "<front>",
  );

  // Substitute paths
  foreach ($paths as $index => $path) {
    foreach ($substitute_patterns as $find => $replace) {
      if (preg_match($find, $path)) {
        $paths[$index] = preg_replace($find, $replace, $path);
      }
    }
  }

  // An array of patterns not to purge from CloudFlare
  $ignore_patterns = array(
    "/^file\/add$/",
    "/^file\/[0-9]+.*$/",
    "/^node\/add.*$/",
    "/^node\/[0-9]+$/",
    "/^node\/[0-9]+\/edit$/",
    "/^the-website-of-the-food-standards-agency$/",
    "/^system\/temporary.*$/",
  );

  // Remove paths to be ignored.
  foreach ($paths as $index => $path) {
    foreach ($ignore_patterns as $pattern) {
      if (preg_match($pattern, $path)) {
        unset($paths[$index]);
      }
    }
  }

  foreach ($paths as $path) {
    if ($counter <= $limit && !empty($path)) {
      if (_fsa_cache_clear_settings('queue_cloudflare', FSA_CACHE_CLEAR_QUEUE_CLOUDFLARE)) {
        _fsa_cache_clear_cloudflare_queue_url($path, $object_type);
      }
      else {
        _fsa_cache_clear_cloudflare_queue_url($path, $object_type, FALSE);
      }
      $counter ++;
    }
  }
}


/**
 * Returns settings for the FSA cache clear module.
 *
 * Settings for this module are stored in a Drupal variable called
 * fsa_cache_clear_settings. We use drupal_static() to avoid repeat calls to the
 * database as we'll need repeat access to the settings.
 *
 * @param string $setting
 *   The name of the setting to retrieve.
 *
 * @param string|array|object|int $default
 *   (optional) A default value to return if the specified setting is empty or
 *   not available.
 *
 * @return string|array|object|NULL|int
 *   The value of the setting requested (if set). If not set and a default has
 *   been specifed via the $default parameter, then this is returned, otherwise
 *   NULL.
 *
 */
function _fsa_cache_clear_settings($setting = NULL, $default = NULL) {

  // Since we'll want to access the settings many times, we use drupal_static()
  // to avoid repeat database calls.
  $settings = &drupal_static(__FUNCTION__);

  // Get the settings from the Drupal variable. Should run just once per load.
  if (!isset($settings)) {
    $settings = variable_get('fsa_cache_clear_settings');
  }

  // Check that we have some settings, that a setting was specified to be
  // retrieved and that the specified setting exists in the array.
  if (!empty($settings) && !empty($setting) && isset($settings[$setting])) {

    switch ($setting) {
      case 'varnish_domains':
      case 'cloudflare_domains':
        // Varnish domains and CloudFlare domains are separated by line breaks
        // in the admin interface, so we use preg_split() to turn them into
        // arrays before returning them. preg_split() handles the cross-platform
        // linebreak issues.
        return preg_split("/\r\n|\n|\r/", trim($settings[$setting]));
        break;
      default:
        return $settings[$setting];
        break;
    }
  }
  // If a $default has been specified, return it now.
  elseif (!empty($default)) {
    return $default;
  }
  // Otherwise, return NULL.
  else {
    return NULL;
  }

}



/**
 * Clears the CloudFlare cache for the given path.
 *
 * @param string $path
 *   The path to be cleared. This should be a Drupal path relative to the site
 *   root, but excluding the leading forward slash, eg
 *   sites/default/files/test.doc
 *
 * @deprecated This function is now deprecated in favour of
 *   `_fsa_cache_clear_cloudflare_queue_url()`. By default, the replacement
 *   function will queue requests for execution on cron, but if the $queue
 *   argument is set to FALSE, it will execute immediately, making it rouhgly
 *   equivalent to this function.
 *
 * @see _fsa_cache_clear_cloudfloare_queue_url()
 * @see https://www.cloudflare.com/docs/client-api.html
 * @see _fsa_cache_clear_cloudflare_purge_individual_url()
 */
function _fsa_cache_clear_cloudflare_purge_url($path = NULL) {

  // If we have no URL, return now.
  if (empty($path)) {
    drupal_set_message('No path supplied', 'error');
    return;
  }

  // An array to hold the URLs to be purged from CloudFlare
  $urls = array();

  // According to the CloudFlare API documentation, we need to clear both HTTP
  // and HTTPS versions of a URL separately
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  // We also need to clear the cache for each of the defined domains.
  foreach (_fsa_cache_clear_settings('cloudflare_domains') as $domain) {
    $urls[] = "http://$domain/$path";
    $urls[] = "https://$domain/$path";
  }

  // Clear each URL from the CloudFlare cache.
  foreach ($urls as $url) {
    try {
      _fsa_cache_clear_cloudflare_purge_individual_url($url);
    }
    catch (Exception $e) {
      watchdog_exception('fsa_cache_clear', $e);
    }
  }

}


/**
 * Add URLs to be purged from CloudFlare to a queue to be executed later.
 *
 * @param string $path
 *   The path to be cleared from the CloudFlare cache
 *
 * @param string $object_type
 *   The type of object corresponding to the path
 *
 * @param boolean $queue
 *   (optional) Determines whether the request to clear the CloudFlare cache for
 *   the given path will be queued for execution on cron run or carried out
 *   immediately. The default is TRUE.
 *
 * @param boolean $force_committee_domains
 *   (optional) If set to TRUE, then if the $object_type is set to file, URLs
 *   will be generated for each committee domain. Defaults to FALSE.
 *
 * @return NULL
 *
 * @see fsa_cache_clear_file_entity_edit_submit()
 * @see _fsa_cache_clear_cloudflare_queue_add_items()
 */
function _fsa_cache_clear_cloudflare_queue_url($path = NULL, $object_type = NULL, $queue = TRUE, $force_committe_domains = FALSE) {

  // If we have no URL, return now.
  if (empty($path)) {
    //drupal_set_message('No path supplied', 'error');
    return;
  }

  // Exclude certain URLs from being purged (mainly internal ones)
  $exclude = array(
    "@^batch$@",
  );

  foreach ($exclude as $pattern) {
    if (preg_match($pattern, $path)) {
      return;
    }
  }

  // An array to hold the URLs to be purged from CloudFlare
  $urls = array();

  // Get the domains set for the CloudFlare cache.
  $domains = _fsa_cache_clear_settings('cloudflare_domains');

  // Get committee domains.
  $committee_domains = _fsa_cache_clear_committee_domains();

  // If we're purging a file object, we need to make sure we purge it from all
  // of the committee subdomains as well as any configured by the users.
  if ($object_type == 'file' && (!$queue || $force_committe_domains)) {
    // Purging of files is now usually handled by the custom submit function:
    // `fsa_cache_clear_file_entity_edit_submit()`. This function handles image
    // derivative files, which can't easily be handled here. The exception to
    // this rule is when the $queue parameter is FALSE, eg when we're using the
    // purge now functionality.
    // Don't clear the homepage for files.
    if ($path == '<front>') {
      return;
    }
    $domains = array_merge($domains, array_keys($committee_domains));
  }

  // If we're not purging a file object, check whether the path matches a
  // committee site, and if so, construct additional URLs based on the committee
  // subdomain. We need to clear for both HTTP and HTTPS versions of the URL.
  else {
    foreach ($committee_domains as $subdomain => $committee_path) {
      if (strpos($path, $committee_path) === 0) {
        $url = $subdomain . '/' . str_replace($committee_path, '', $path);
        $url = str_replace('//', '/', $url);
        $urls[] = "http://$url";
        $urls[] = "https://$url";
      }
    }
  }

  // According to the CloudFlare API documentation, we need to clear both HTTP
  // and HTTPS versions of a URL separately
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  // We also need to clear the cache for each of the defined domains.
  foreach ($domains as $domain) {
    $urls[] = "http://$domain/$path";
    $urls[] = "https://$domain/$path";
  }

  if ($queue) {
    // Add the URLs to the queue to be cleared.
    _fsa_cache_clear_cloudflare_queue_add_items($urls);
  }
  else {
    // Clear each URL from the CloudFlare cache.
    foreach ($urls as $url) {
      try {
        _fsa_cache_clear_cloudflare_purge_individual_url($url);
      }
      catch (Exception $e) {
        watchdog_exception('fsa_cache_clear', $e);
      }
    }
  }

}

/**
 * Adds URLs to be purged from CloudFlare to the queue.
 *
 * @param array $urls
 *   An array of fully-qualified URLs to be purged from the CloudFlare cache
 *
 * @return NULL
 *
 * @see _fsa_cache_clear_cloudflare_queue_url()
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function _fsa_cache_clear_cloudflare_queue_add_items($urls = array()) {

  // If there are no items to queue, exit now.
  if (empty($urls)) {
    return;
  }

  // Create or open the queue.
  $queue = DrupalQueue::get(FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME);

  // Add each URL to the queue
  foreach ($urls as $url) {
    // Identify the homepage and remove the <front> part
    if (strpos($url, '/<front>')) {
      $url = str_replace('/<front>', '', $url);
    }
    $queue->createItem($url);
  }
}


/**
 * Adds URLs to be purged from CloudFlare to the queue.
 *
 * @param array $urls
 *   An array of fully-qualified URLs to be purged from the CloudFlare cache
 *
 * @return NULL
 *
 * @see _fsa_cache_clear_cloudflare_queue_url()
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function _fsa_cache_clear_varnish_queue_add_items($urls = array()) {

  // If there are no items to queue, exit now.
  if (empty($urls)) {
    return;
  }

  // Create or open the queue.
  $queue = DrupalQueue::get(FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME);

  // Add each URL to the queue
  foreach ($urls as $url) {
    // Identify the homepage and remove the <front> part
    if (strpos($url, '/<front>')) {
      $url = str_replace('/<front>', '', $url);
    }
    $queue->createItem($url);
  }
}


/**
 * Implements hook_cron_queue_info().
 *
 * This hook is called when cron is run and is used to purge URLs from the
 * CloudFlare cache.
 *
 * @return array
 *   Queues to be executed on Cron.
 *
 * @see _fsa_cache_clear_cloudflare_purge_individual_url()
 */
function fsa_cache_clear_cron_queue_info() {
  $queues = array();
  $queues[FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME] = array(
    'worker callback' => '_fsa_cache_clear_varnish_purge',
    'time' => FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME,
  );
  // Don't return CloudFlare queue items as we're now using a hook_cron()
  // implementation instead.
  // @see fsa_cache_clear_cron()
  //$queues[FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME] = array(
  //  'worker callback' => '_fsa_cache_clear_cloudflare_purge_individual_url',
  //  'time' => FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME,
  //);

  return $queues;
}


/**
 * Implements hook_cron().
 */
function fsa_cache_clear_cron() {
  // Get the queue of URLs be be Cleared from CloudFlare
  $queue = DrupalQueue::get(FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME);
  $queue->createQueue();

  // Determine the number of items in the queue
  $queue_length = $queue->numberOfItems();

  // If the queue is empty, exit now.
  if ($queue_length == 0) {
    return;
  }

  // Get the setting for the maximum number of CloudFlare URLs per cron run
  $max_items = _fsa_cache_clear_settings('cloudflare_max_items', 10);
  // If there are fewer items in the queue than $max_items, use queue length
  $max_items = $queue_length < $max_items ? $queue_length : $max_items;

  // Item couner
  $item_counter = 1;

  // Loop through the items in the queue up to a maximum of $max_items
  while ($item_counter <= $max_items) {
    // Claim the next item from the queue
    $item = $queue->claimItem();

    // If $item is not an object or if $item->data is empty, continue.
    if (!is_object($item) || empty($item->data)) {
      $item_counter++;
      continue;
    }

    // Try to purge the item from the CloudFlare queue
    try {
      if (_fsa_cache_clear_cloudflare_purge_individual_url($item->data)) {
        // If successful, delete the item from the queue
        $queue->deleteItem($item);
      }
      else {
        watchdog('fsa_cache_clear', 'Failed to purge: ' . $item->data, NULL, WATCHDOG_ERROR);
        // If the purge fails, for whatever reason, release the item for next time
        $queue->releaseItem($item);
      }
    }
    // Catch any exceptions and log an error message.
    catch (Exception $e) {
      watchdog_exception('fsa_cache_clear', $e);
    }

    // Increment the counter
    $item_counter++;
  }
}


/**
 * Purges an individual URL from the CloudFlare cache.
 *
 * @param string $url
 *   The full URL - inculding protocol and domain - to be purged from CloudFlare
 * @return NULL
 */
function _fsa_cache_clear_cloudflare_purge_individual_url($url = NULL) {

  // If we don't have a URL, exit now.
  if (empty($url)) {
    return FALSE;
  }

  // Get the CloudFlare endpoint. We specify a default in case it's not set,
  // but this can be overridden via the configuration UI for this module.
  $endpoint = _fsa_cache_clear_settings('cloudflare_endpoint', 'https://www.cloudflare.com/api_json.html');

  // Settings for the CloudFlare API
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  $data = array(
    'a' => 'zone_file_purge',
    'tkn' => _fsa_cache_clear_settings('cloudflare_api_key'),
    'email' => _fsa_cache_clear_settings('cloudflare_email'),
    'z' => 'food.gov.uk',
    'url' => $url,
  );

  // Turn the settings into a string of the form a=b&c=d.
  $data = http_build_query($data);

  // Array of headers to be passed with the request to CloudFlare endpoint.
  $headers = array(
    "Content-type: application/x-www-form-urlencoded",
    "Content-Length: " . strlen($data),
    "Connection: close",
  );

  // Set stream context options.
  $context_options = array (
    'http' => array (
      'method' => 'POST',
      'header' => implode("\r\n", $headers) . "\r\n",
      'content' => $data,
    ),
  );

    // Create the stream context.
    $context = stream_context_create($context_options);

    // Make the request.
    $fp = file_get_contents($endpoint, false, $context);

    // Decode the results.
    $result_object = json_decode($fp);
    if (is_object($result_object) && !empty($result_object->result) && $result_object->result == 'success') {
      _fsa_cache_clear_log_message('cloudflare_purge', 'Successfully purged @url from the CloudFlare cache.', array('@url' => $url));
      return TRUE;
    }
    // If the purge fails, throw an exception, including the CloudFlare error
    // code and message.
    else {
      _fsa_cache_clear_log_message('cloudflare_purge', 'An error occurred purging @url from the CloudFlare cache.', array('@url' => $url), WATCHDOG_ERROR);
      $error_message = t("Failed to purge item $url from the CloudFlare cache.");
      if (is_object($result_object)) {
        $error_message .= !empty($result_object->msg) ? ' ' . $result_object->msg : '';
        $error_message .= !empty($result_object->err_code) ? ' (' . $result_object->err_code . ')' : '';
      }
      throw new Exception($error_message);
      return FALSE;
    }

}

/**
 * Provides customisable message logging for cache clearing events.
 *
 * @param string $type
 *   Type of action.
 *
 * @param string $message
 *   The message to log
 *
 * @param array $variables
 *   Any variables to be substituted into the message.
 *
 * @param int $level
 *   The severity of the message. (Uses Watchdog levels)
 *
 * @return NULL
 */
function _fsa_cache_clear_log_message($type = NULL, $message = '', $variables = array(), $level = WATCHDOG_INFO) {

  // If $type or $message are empty, exit now.
  if (empty($type) || empty($message)) {
    return;
  }

  // Array of settings for logging.
  $log_settings = array(

    'cloudflare_purge' => array(
      WATCHDOG_ERROR => array(
        'watchdog' => TRUE,
        'message' => FALSE,
      ),

      WATCHDOG_INFO => array(
        'watchdog' => FALSE,
        'message' => FALSE,
      ),
    ),

    'varnish_purge' => array(
      WATCHDOG_INFO => array(
        'watchdog' => FALSE,
        'message' => FALSE,
      ),
    ),
  );

  // Determines whether to log to watchdog.
  $log_watchdog = !empty($log_settings[$type]) && !empty($log_settings[$type][$level]) ? $log_settings[$type][$level]['watchdog'] : FALSE;
  // Determines whether to log a Drupal message.
  $log_message = !empty($log_settings[$type]) && !empty($log_settings[$type][$level]) ? $log_settings[$type][$level]['message'] : FALSE;

  // Log message as required.
  if ($log_watchdog) {
    watchdog('FSA Cache Clear', $message, $variables, $level);
  }
  if ($log_message) {

    switch ($level) {
      case 0:
      case 1:
      case 2:
      case 3:
        $message_type = 'error';
        break;
      case 4:
      case 5:
        $message_type = 'warning';
        break;
      case 6:
      case 7:
        $message_type = 'status';
        break;
      default:
        $message_type = 'status';
        break;
    }

    $message = format_string($message, $variables);
    drupal_set_message($message, $message_type);
  }
}


/**
 * Returns an array of committee domains and their associated paths.
 *
 * @return array
 *   Array of committee domains and their associated paths.
 */
function _fsa_cache_clear_committee_domains() {
  $committee_domains = array(
    'cot.food.gov.uk' => 'committee/committee-on-toxicity',
    'acmsf.food.gov.uk' => 'committee/acmsf',
    'acnfp.food.gov.uk'=> 'committee/acnfp',
    'acaf.food.gov.uk' => 'committee/acaf',
    'gacs.food.gov.uk'=> 'committee/gacs',
    'ssrc.food.gov.uk'=> 'committee/social-science-research-committee-ssrc',
  );
  return $committee_domains;
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function fsa_cache_clear_form_file_entity_edit_alter(&$form, &$form_state, $form_id) {
  if (!empty($form['actions']['submit']['#submit'])) {
    // Add our submit handler to the file_entity edit form.
    array_unshift($form['actions']['submit']['#submit'], 'fsa_cache_clear_file_entity_edit_submit');
  }
}


/**
 * Additional submit handler for the file entity edit form.
 *
 * We use this to determine which derived image files exist before they are
 * deleted. We can then purge these derived files from CloudFlare.
 */
function fsa_cache_clear_file_entity_edit_submit($form, &$form_state) {
  // Get the file object
  $file = !empty($form_state['file']) ? $form_state['file'] : NULL;
  // Get the replacement file object
  $replace_file = !empty($form_state['values']['replace_upload']) ? TRUE : FALSE;
  // If we have no file object or replacement file object, return now.
  if (empty($file) || empty($replace_file)) {
    return;
  }
  // An array to hold URLs for clearing.
  $urls = array();
  // Filename for the file to be replaced
  $filename = file_uri_target($file->uri);
  // Get the path for public files.
  $public_path = variable_get('file_public_path');
  // Add the filename to the URLs for clearing
  $urls[] =  "$public_path/$filename";
  // Clear the Varnish cache for the URL
  _fsa_cache_clear_varnish_purge("$public_path/$filename");
  // If the file is an image, we need to check whether it has any existing
  // style derivatives, as these will need to be cleared from CloudFlare too.
  if ($file->type == 'image') {
    $image_styles = image_styles();
    foreach ($image_styles as $style_name => $style_properties) {
      if (file_exists(image_style_path($style_name, $filename))) {
        // Clear the Varnish cache for the derived images.
        _fsa_cache_clear_varnish_purge($public_path . '/' . file_uri_target(image_style_path($style_name, $filename)));
        // Get the image style token to add to the URL for CloudFlare
        $image_style_path_token = image_style_path_token($style_name,  "public://$filename");
        // Add the path to be cleared from the Varnish cache to the queue
        _fsa_cache_clear_varnish_queue_add_items(array($public_path . '/' . file_uri_target(image_style_path($style_name, $filename))));
        // Add the path to be cleared from the CloudFlare cache, including the
        // image derivative token as this is stored in CloudFlare.
        $urls[] = $public_path . '/' . file_uri_target(image_style_path($style_name, $filename)) . "?" . IMAGE_DERIVATIVE_TOKEN . "=$image_style_path_token";
      }
    }
  }
  // Get the list of domains from which this file needs to be cleared.
  $domains = array_merge(_fsa_cache_clear_settings('cloudflare_domains'), array_keys(_fsa_cache_clear_committee_domains()));
  $clear_urls = array();
  foreach ($domains as $domain) {
    foreach ($urls as $url) {
      // We need to clear both http and https versions.
      $clear_urls[] = "http://$domain/$url";
      $clear_urls[] = "https://$domain/$url";
    }
  }
  // Add the items to the CloudFlare queue to be cleared on cron.
  _fsa_cache_clear_cloudflare_queue_add_items($clear_urls);
}


/**
 * Helper function to get the object type based on path
 *
 * This is very rudimentary, but for our purposes, we don't need anything
 * especially sophisticated, since we use this function primarily within the
 * purge now functionality.
 *
 * @see fsa_cache_clear_purge_form_submit()
 */
function _fsa_cache_clear_get_object_type_from_path($path) {
  if (empty($path)) {
    return NULL;
  }

  $public_path = variable_get('file_public_path');
  $private_path = 'system/files';

  // Is it a file path
  if (strpos($path, $public_path) === 0 || strpos($path, $private_path) === 0) {
    return 'file';
  }

  // Is it an unaliased node page?
  if (strpos($path, 'node/') === 0 && strpos($path, 'node/add') === FALSE) {
    return 'node';
  }

  // Is it a user path?
  if (preg_match("/^user\/[0-9]+$/", $path)) {
    return 'user';
  }

  // Check if our path is a node alias
  if (preg_match("/^node\/[0-9]+/", drupal_lookup_path('source', $path))) {
    return 'node';
  }

  return 'unknown';
}


/**
 * Implements hook_file_operations().
 */
function fsa_cache_clear_file_operations() {
  $operations = array(
    'delete' => array(
      'label' => t('Purge from CloudFlare cache'),
      'callback' => '_fsa_cache_clear_file_operation_cloudflare_purge',
    ),
  );
  return $operations;
}


/**
 * Implements hook_action_info().
 *
 * @see fsa_cache_clear_file_purge_cloudflare_action()
 */
function fsa_cache_clear_action_info() {
  return array(
    'fsa_cache_clear_file_purge_cloudflare_action' => array(
      'type' => 'file',
      'label' => t('Purge from CloudFlare cache'),
      'configurable' => FALSE,
      //'behavior' => array('changes_property'),
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}


/**
 * Action callback for purging files from CloudFlare
 */
function fsa_cache_clear_file_purge_cloudflare_action($file, $context) {

  // If we don't have a file, exit now
  if (empty($file)) {
    return;
  }

  // Get the filename
  $filename = file_uri_target($file->uri);
  // Get the path for public files.
  $public_path = variable_get('file_public_path');
  // Add the filename to the URLs for clearing
  $urls = array("$public_path/$filename");
  // Handle image derivatives
  if ($file->type == 'image') {
    $image_styles = image_styles();
    foreach ($image_styles as $style_name => $style_properties) {
      if (file_exists(image_style_path($style_name, $filename))) {
        // Get the image style token to add to the URL for CloudFlare
        $image_style_path_token = image_style_path_token($style_name,  "public://$filename");
        // Add the path to be cleared from the CloudFlare cache, including the
        // image derivative token as this is stored in CloudFlare.
        $urls[] = $public_path . '/' . file_uri_target(image_style_path($style_name, $filename)) . "?" . IMAGE_DERIVATIVE_TOKEN . "=$image_style_path_token";
      }
    }
  }
  foreach ($urls as $url) {
    _fsa_cache_clear_cloudflare_queue_url($url, 'file', TRUE, TRUE);
  }
}

/**
 * Callback for CloudFlare purge file operation
 */
function _fsa_cache_clear_file_operation_cloudflare_purge() {
  // Not currently implemented as a view is used in place of the standard
  // files admin page.
}
