<?php
/**
 * @file
 * Module file for the FSA enhanced cache clearing module. This is used to clear
 * additional domains from Varnish and to clear URLs from the CloudFlare cache.
 *
 * This module draws heavily on existing functionality provided by the Varnish
 * and Expire modules, without which it will not work.
 */

/**
 * Default value for whether to queue CloudFlare cache purges
 * This can be overridden via the admin user interface.
 */
define('FSA_CACHE_CLEAR_QUEUE_CLOUDFLARE', TRUE);

/**
 * Sets the name of the cloudflare cache queue
 */
define('FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME', 'fsa_cache_clear_cloudflare_urls');

/**
 * Sets the name of the Varnish cache queue
 */
define('FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME', 'fsa_cache_clear_varnish_urls');


/**
 * Determines how much time is available for cache clearing at cron runs.
 */
define('FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME', 180);

/**
 * Implementation of hook_menu().
 */
function fsa_cache_clear_menu() {

  // Configuration interface.
  $items['admin/config/development/fsa-cache-clear'] = array(
    'title' => 'FSA cache clearing',
    'description' => 'Settings for clearing Varnish and CloudFlare caches.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fsa_cache_clear_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'fsa_cache_clear.admin.inc',
  );

  // A test interface.
  $items['admin/config/development/fsa-cache-clear/purge'] = array(
    'title' => t('Purge URLs'),
    'description' => t('Purge a URL from the Varnish and/or CloudFlare caches'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fsa_cache_clear_purge_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'fsa_cache_clear.admin.inc',
  );

  return $items;
}


/*
 * Implements hook_expire_cache().
 *
 * This hook is provided by the Expire module, and will be run according to the
 * configuration settings for that module as specified here:
 * admin/config/system/expire
 *
 */
function fsa_cache_clear_expire_cache($urls, $wildcards, $object_type, $object) {

  // Clear the Varnish cache for any additional domains.
  _fsa_cache_clear_varnish_purge($urls);

  // Clear the CloudFlare cache if activated. This is determined via the
  // configuration UI using a checkbox.
  if (_fsa_cache_clear_settings('clear_cloudflare')) {
    _fsa_cache_clear_cloudflare_purge($urls, $object_type);
  }

}

/**
 * Purge the Varnish cache for the given paths.
 *
 * This is essentially just a wrapper for the varnish_purge() function. The
 * main purpose is to clear paths for any additional domains specified via this
 * module's configuration interface.
 *
 * @param array $paths
 *   An array of paths to be purged from Varnish.
 *
 * @see varnish_purge()
 * @see varnish_expire_cache()
 */
function _fsa_cache_clear_varnish_purge($paths) {

  // This function requires the varnish_purge() function, so if we don't have
  // it, exit now.
  if (!function_exists('varnish_purge')) {
    return;
  }

  // We need $paths to be an array. If it's not, make it one now.
  if (!is_array($paths)) {
    $paths = array($paths);
  }

  // Get the base_path.
  $base = base_path();

  // Get the domains to clear from the settings.
  $domains = _fsa_cache_clear_settings('varnish_domains');

  // Check that we have some domains and that $domains is an array.
  if (empty($domains) || !is_array($domains)) {
    return;
  }

  // Get the $host that the Varnish module already defines. There's no need to
  // clear the cache for that domain a second time.
  $host = function_exists('_varnish_get_host') ? _varnish_get_host() : '';
  // Remove $host from the array of domains - if present.
  $domains = array_diff($domains, array(trim($host)));

  // Make sure we still have some domains. If not, return now.
  if (empty($domains)) {
    return;
  }

  // For each additional domain, clear the relevant paths from Varnish.
  // @see varnish_expire_cache()
  foreach ($domains as $host) {
    $purge = implode('$|^' . $base, $paths);
    $purge = '^'. $base . $purge .'$';
    varnish_purge($host, $purge);
    print "Host: $host";
    print "Purge: $purge";
    _fsa_cache_clear_log_message('varnish_purge', 'Successfully purged @purge for host @host from the Varnish cache.', array('@purge' => $purge, '@host' => $host));
  }
}


/**
 * Clear the CloudFlare cache for the given URLs.
 */
function _fsa_cache_clear_cloudflare_purge($paths = array(), $object_type = NULL) {

  // Get an array of the types of objects for which we want to clear the
  // CloudFlare cache.
  $object_types = array_filter(_fsa_cache_clear_settings('cloudflare_object_types'));

  // If we don't have a path specified, or we don't have an object type, or
  // the object type is not one that we want to clear the CloudFlare cache for,
  // then exit now.
  if (empty($paths) || empty($object_type) || !in_array($object_type, $object_types)) {
    return;
  }

  // Get the limit for the number of items to clear from the CloudFlare cache
  // per page update/deletion.
  $limit = _fsa_cache_clear_settings('cloudflare_max_items');
  // Assume a default limit of 10 items.
  $limit = !empty($limit) ? $limit : 10;
  $counter = 1;

  // An array of path patterns to substitute
  $substitute_patterns = array(
    "/^the-website-of-the-food-standards-agency$/" => "<front>",
  );

  // Substitute paths
  foreach ($paths as $index => $path) {
    foreach ($substitute_patterns as $find => $replace) {
      if (preg_match($find, $path)) {
        $paths[$index] = preg_replace($find, $replace, $path);
      }
    }
  }

  // An array of patterns not to purge from CloudFlare
  $ignore_patterns = array(
    "/^file\/add$/",
    "/^file\/[0-9]+.*$/",
    "/^node\/add.*$/",
    "/^node\/[0-9]+$/",
    "/^node\/[0-9]+\/edit$/",
    "/^the-website-of-the-food-standards-agency$/",
    "/^system\/temporary.*$/",
  );

  // Remove paths to be ignored.
  foreach ($paths as $index => $path) {
    foreach ($ignore_patterns as $pattern) {
      if (preg_match($pattern, $path)) {
        unset($paths[$index]);
      }
    }
  }

  foreach ($paths as $path) {
    if ($counter <= $limit && !empty($path)) {
      if (_fsa_cache_clear_settings('queue_cloudflare', FSA_CACHE_CLEAR_QUEUE_CLOUDFLARE)) {
        _fsa_cache_clear_cloudflare_queue_url($path, $object_type);
      }
      else {
        _fsa_cache_clear_cloudflare_purge_url($path);
      }
      $counter ++;
    }
  }
}


/**
 * Returns settings for the FSA cache clear module.
 *
 * Settings for this module are stored in a Drupal variable called
 * fsa_cache_clear_settings. We use drupal_static() to avoid repeat calls to the
 * database as we'll need repeat access to the settings.
 *
 * @param string $setting
 *   The name of the setting to retrieve.
 *
 * @param string|array|object|int $default
 *   (optional) A default value to return if the specified setting is empty or
 *   not available.
 *
 * @return string|array|object|NULL|int
 *   The value of the setting requested (if set). If not set and a default has
 *   been specifed via the $default parameter, then this is returned, otherwise
 *   NULL.
 *
 */
function _fsa_cache_clear_settings($setting = NULL, $default = NULL) {

  // Since we'll want to access the settings many times, we use drupal_static()
  // to avoid repeat database calls.
  $settings = &drupal_static(__FUNCTION__);

  // Get the settings from the Drupal variable. Should run just once per load.
  if (!isset($settings)) {
    $settings = variable_get('fsa_cache_clear_settings');
  }

  // Check that we have some settings, that a setting was specified to be
  // retrieved and that the specified setting exists in the array.
  if (!empty($settings) && !empty($setting) && isset($settings[$setting])) {

    switch ($setting) {
      case 'varnish_domains':
      case 'cloudflare_domains':
        // Varnish domains and CloudFlare domains are separated by line breaks
        // in the admin interface, so we use preg_split() to turn them into
        // arrays before returning them. preg_split() handles the cross-platform
        // linebreak issues.
        return preg_split("/\r\n|\n|\r/", trim($settings[$setting]));
        break;
      default:
        return $settings[$setting];
        break;
    }
  }
  // If a $default has been specified, return it now.
  elseif (!empty($default)) {
    return $default;
  }
  // Otherwise, return NULL.
  else {
    return NULL;
  }

}



/**
 * Clears the CloudFlare cache for the given path.
 *
 * @param string $path
 *   The path to be cleared. This should be a Drupal path relative to the site
 *   root, but excluding the leading forward slash, eg
 *   sites/default/files/test.doc
 *
 * @see https://www.cloudflare.com/docs/client-api.html
 * @see _fsa_cache_clear_cloudflare_purge_individual_url().
 */
function _fsa_cache_clear_cloudflare_purge_url($path = NULL) {

  // If we have no URL, return now.
  if (empty($path)) {
    drupal_set_message('No path supplied', 'error');
    return;
  }

  // An array to hold the URLs to be purged from CloudFlare
  $urls = array();

  // According to the CloudFlare API documentation, we need to clear both HTTP
  // and HTTPS versions of a URL separately
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  // We also need to clear the cache for each of the defined domains.
  foreach (_fsa_cache_clear_settings('cloudflare_domains') as $domain) {
    $urls[] = "http://$domain/$path";
    $urls[] = "https://$domain/$path";
  }

  // Clear each URL from the CloudFlare cache.
  foreach ($urls as $url) {
    _fsa_cache_clear_cloudflare_purge_individual_url($url);
  }

}



/**
 * Add URLs to be purged from CloudFlare to a queue to be executed later.
 *
 * @param string $path
 *   The path to be cleared from the CloudFlare cache
 *
 * @return NULL
 *
 * @see fsa_cache_clear_file_entity_edit_submit()
 * @see _fsa_cache_clear_cloudflare_queue_add_items()
 */
function _fsa_cache_clear_cloudflare_queue_url($path = NULL, $object_type = NULL) {

  // If we have no URL, return now.
  if (empty($path)) {
    drupal_set_message('No path supplied', 'error');
    return;
  }

  // An array to hold the URLs to be purged from CloudFlare
  $urls = array();

  // Get the domains set for the CloudFlare cache.
  $domains = _fsa_cache_clear_settings('cloudflare_domains');

  // Get committee domains.
  $committee_domains = _fsa_cache_clear_committee_domains();

  // If we're purging a file object, we need to make sure we purge it from all
  // of the committee subdomains as well as any configured by the users.
  if ($object_type == 'file') {
    // Purging of files is now handled by the custom submit function:
    // fsa_cache_clear_file_entity_edit_submit(). This function handles image
    // derivative files, which can't easily be handled here. We therefore return
    // early if the object is a file.
    return;
    // Don't clear the homepage for files.
    if ($path == '<front>') {
      return;
    }
    $domains = array_merge($domains, array_keys($committee_domains));
  }

  // If we're not purging a file object, check whether the path matches a
  // committee site, and if so, construct additional URLs based on the committee
  // subdomain. We need to clear for both HTTP and HTTPS versions of the URL.
  else {
    foreach ($committee_domains as $subdomain => $committee_path) {
      if (strpos($path, $committee_path) === 0) {
        $url = $subdomain . '/' . str_replace($committee_path, '', $path);
        $url = str_replace('//', '/', $url);
        $urls[] = "http://$url";
        $urls[] = "https://$url";
      }
    }
  }

  // According to the CloudFlare API documentation, we need to clear both HTTP
  // and HTTPS versions of a URL separately
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  // We also need to clear the cache for each of the defined domains.
  foreach ($domains as $domain) {
    $urls[] = "http://$domain/$path";
    $urls[] = "https://$domain/$path";
  }

  // Add the URLs to the queue to be cleared.
  _fsa_cache_clear_cloudflare_queue_add_items($urls);

}

/**
 * Adds URLs to be purged from CloudFlare to the queue.
 *
 * @param array $urls
 *   An array of fully-qualified URLs to be purged from the CloudFlare cache
 *
 * @return NULL
 *
 * @see _fsa_cache_clear_cloudflare_queue_url()
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function _fsa_cache_clear_cloudflare_queue_add_items($urls = array()) {

  // If there are no items to queue, exit now.
  if (empty($urls)) {
    return;
  }

  // Create or open the queue.
  $queue = DrupalQueue::get(FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME);

  // Add each URL to the queue
  foreach ($urls as $url) {
    // Identify the homepage and remove the <front> part
    if (strpos($url, '/<front>')) {
      $url = str_replace('/<front>', '', $url);
    }
    $queue->createItem($url);
  }
}


/**
 * Adds URLs to be purged from CloudFlare to the queue.
 *
 * @param array $urls
 *   An array of fully-qualified URLs to be purged from the CloudFlare cache
 *
 * @return NULL
 *
 * @see _fsa_cache_clear_cloudflare_queue_url()
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function _fsa_cache_clear_varnish_queue_add_items($urls = array()) {

  // If there are no items to queue, exit now.
  if (empty($urls)) {
    return;
  }

  // Create or open the queue.
  $queue = DrupalQueue::get(FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME);

  // Add each URL to the queue
  foreach ($urls as $url) {
    // Identify the homepage and remove the <front> part
    if (strpos($url, '/<front>')) {
      $url = str_replace('/<front>', '', $url);
    }
    $queue->createItem($url);
  }
}


/**
 * Implements hook_cron_queue_info().
 *
 * This hook is called when cron is run and is used to purge URLs from the
 * CloudFlare cache.
 *
 * @return array
 *   Queues to be executed on Cron.
 *
 * @see _fsa_cache_clear_cloudflare_purge_individual_url()
 */
function fsa_cache_clear_cron_queue_info() {
  $queues = array();
  $queues[FSA_CACHE_CLEAR_CLOUDFLARE_QUEUE_NAME] = array(
    'worker callback' => '_fsa_cache_clear_cloudflare_purge_individual_url',
    'time' => FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME,
  );
  $queues[FSA_CACHE_CLEAR_VARNISH_QUEUE_NAME] = array(
    'worker callback' => '_fsa_cache_clear_varnish_purge',
    'time' => FSA_CACHE_CLEAR_CLOUDFLARE_CRON_TIME,
  );
  return $queues;
}


/**
 * Purges an individual URL from the CloudFlare cache.
 *
 * @param string $url
 *   The full URL - inculding protocol and domain - to be purged from CloudFlare
 * @return NULL
 */
function _fsa_cache_clear_cloudflare_purge_individual_url($url = NULL) {

  // If we don't have a URL, exit now.
  if (empty($url)) {
    return;
  }

  // Get the CloudFlare endpoint. We specify a default in case it's not set,
  // but this can be overridden via the configuration UI for this module.
  $endpoint = _fsa_cache_clear_settings('cloudflare_endpoint', 'https://www.cloudflare.com/api_json.html');

  // Settings for the CloudFlare API
  // @see https://www.cloudflare.com/docs/client-api.html#s4.5
  $data = array(
    'a' => 'zone_file_purge',
    'tkn' => _fsa_cache_clear_settings('cloudflare_api_key'),
    'email' => _fsa_cache_clear_settings('cloudflare_email'),
    'z' => 'food.gov.uk',
    'url' => $url,
  );

  // Turn the settings into a string of the form a=b&c=d.
  $data = http_build_query($data);

  // Array of headers to be passed with the request to CloudFlare endpoint.
  $headers = array(
    "Content-type: application/x-www-form-urlencoded",
    "Content-Length: " . strlen($data),
    "Connection: close",
  );

  // Set stream context options.
  $context_options = array (
    'http' => array (
      'method' => 'POST',
      'header' => implode("\r\n", $headers) . "\r\n",
      'content' => $data,
    ),
  );

    // Create the stream context.
    $context = stream_context_create($context_options);

    // Make the request.
    $fp = file_get_contents($endpoint, false, $context);

    // Decode the results.
    $result_object = json_decode($fp);
    if (is_object($result_object) && !empty($result_object->result) && $result_object->result == 'success') {
      _fsa_cache_clear_log_message('cloudflare_purge', 'Successfully purged @url from the CloudFlare cache.', array('@url' => $url));
    }
    else {
      _fsa_cache_clear_log_message('cloudflare_purge', 'An error occurred purging @url from the CloudFlare cache.', array('@url' => $url), WATCHDOG_ERROR);
    }

}

/**
 * Provides customisable message logging for cache clearing events.
 *
 * @param string $type
 *   Type of action.
 *
 * @param string $message
 *   The message to log
 *
 * @param array $variables
 *   Any variables to be substituted into the message.
 *
 * @param int $level
 *   The severity of the message. (Uses Watchdog levels)
 *
 * @return NULL
 */
function _fsa_cache_clear_log_message($type = NULL, $message = '', $variables = array(), $level = WATCHDOG_INFO) {

  // If $type or $message are empty, exit now.
  if (empty($type) || empty($message)) {
    return;
  }

  // Array of settings for logging.
  $log_settings = array(

    'cloudflare_purge' => array(
      WATCHDOG_ERROR => array(
        'watchdog' => TRUE,
        'message' => FALSE,
      ),

      WATCHDOG_INFO => array(
        'watchdog' => FALSE,
        'message' => FALSE,
      ),
    ),

    'varnish_purge' => array(
      WATCHDOG_INFO => array(
        'watchdog' => FALSE,
        'message' => FALSE,
      ),
    ),
  );

  // Determines whether to log to watchdog.
  $log_watchdog = !empty($log_settings[$type]) && !empty($log_settings[$type][$level]) ? $log_settings[$type][$level]['watchdog'] : FALSE;
  // Determines whether to log a Drupal message.
  $log_message = !empty($log_settings[$type]) && !empty($log_settings[$type][$level]) ? $log_settings[$type][$level]['message'] : FALSE;

  // Log message as required.
  if ($log_watchdog) {
    watchdog('FSA Cache Clear', $message, $variables, $level);
  }
  if ($log_message) {

    switch ($level) {
      case 0:
      case 1:
      case 2:
      case 3:
        $message_type = 'error';
        break;
      case 4:
      case 5:
        $message_type = 'warning';
        break;
      case 6:
      case 7:
        $message_type = 'status';
        break;
      default:
        $message_type = 'status';
        break;
    }

    $message = format_string($message, $variables);
    drupal_set_message($message, $message_type);
  }
}


/**
 * Returns an array of committee domains and their associated paths.
 *
 * @return array
 *   Array of committee domains and their associated paths.
 */
function _fsa_cache_clear_committee_domains() {
  $committee_domains = array(
    'cot.food.gov.uk' => 'committee/committee-on-toxicity',
    'acmsf.food.gov.uk' => 'committee/acmsf',
    'acnfp.food.gov.uk'=> 'committee/acnfp',
    'acaf.food.gov.uk' => 'committee/acaf',
    'gacs.food.gov.uk'=> 'committee/gacs',
    'ssrc.food.gov.uk'=> 'committee/social-science-research-committee-ssrc',
  );
  return $committee_domains;
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see fsa_cache_clear_file_entity_edit_submit()
 */
function fsa_cache_clear_form_file_entity_edit_alter(&$form, &$form_state, $form_id) {
  if (!empty($form['actions']['submit']['#submit'])) {
    // Add our submit handler to the file_entity edit form.
    array_unshift($form['actions']['submit']['#submit'], 'fsa_cache_clear_file_entity_edit_submit');
  }
}


/**
 * Additional submit handler for the file entity edit form.
 *
 * We use this to determine which derived image files exist before they are
 * deleted. We can then purge these derived files from CloudFlare.
 */
function fsa_cache_clear_file_entity_edit_submit($form, &$form_state) {
  // Get the file object
  $file = !empty($form_state['file']) ? $form_state['file'] : NULL;
  // Get the replacement file object
  $replace_file = !empty($form_state['values']['replace_upload']) ? TRUE : FALSE;
  // If we have no file object or replacement file object, return now.
  if (empty($file) || empty($replace_file)) {
    return;
  }
  // An array to hold URLs for clearing.
  $urls = array();
  // Filename for the file to be replaced
  $filename = file_uri_target($file->uri);
  // Get the path for public files.
  $public_path = variable_get('file_public_path');
  // Add the filename to the URLs for clearing
  $urls[] =  "$public_path/$filename";
  // Clear the Varnish cache for the URL
  _fsa_cache_clear_varnish_purge("$public_path/$filename");
  // If the file is an image, we need to check whether it has any existing
  // style derivatives, as these will need to be cleared from CloudFlare too.
  if ($file->type == 'image') {
    $image_styles = image_styles();
    foreach ($image_styles as $style_name => $style_properties) {
      if (file_exists(image_style_path($style_name, $filename))) {
        // Clear the Varnish cache for the derived images.
        //dpm("Clearing from Varnish: $public_path" . '/' . file_uri_target(image_style_path($style_name, $filename)));
        _fsa_cache_clear_varnish_purge($public_path . '/' . file_uri_target(image_style_path($style_name, $filename)));
        // Add the path to be cleared from the Varnish cache to the queue
        _fsa_cache_clear_varnish_queue_add_items(array($public_path . '/' . file_uri_target(image_style_path($style_name, $filename))));
        $urls[] = $public_path . '/' . file_uri_target(image_style_path($style_name, $filename));
      }
    }
  }
  // Get the list of domains from which this file needs to be cleared.
  $domains = array_merge(_fsa_cache_clear_settings('cloudflare_domains'), array_keys(_fsa_cache_clear_committee_domains()));
  $clear_urls = array();
  foreach ($domains as $domain) {
    foreach ($urls as $url) {
      // We need to clear both http and https versions.
      $clear_urls[] = "http://$domain/$url";
      $clear_urls[] = "https://$domain/$url";
    }
  }
  // Add the items to the CloudFlare queue to be cleared on cron.
  _fsa_cache_clear_cloudflare_queue_add_items($clear_urls);
}
